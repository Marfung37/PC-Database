import { InnerOperation, Piece, Rotation } from './defines';
import { Field } from './field';
export declare function createNewInnerField(): InnerField;
export declare function createInnerField(field: Field): InnerField;
export declare class InnerField {
    private readonly field;
    private readonly garbage;
    private static create;
    constructor({ field, garbage, }: {
        field?: PlayField;
        garbage?: PlayField;
    });
    fill(operation: InnerOperation): void;
    fillAll(positions: {
        x: number;
        y: number;
    }[], type: Piece): void;
    canFill(piece: Piece, rotation: Rotation, x: number, y: number): boolean;
    canFillAll(positions: {
        x: number;
        y: number;
    }[]): boolean;
    isOnGround(piece: Piece, rotation: Rotation, x: number, y: number): boolean;
    clearLine(): void;
    riseGarbage(): void;
    mirror(): void;
    shiftToLeft(): void;
    shiftToRight(): void;
    shiftToUp(): void;
    shiftToBottom(): void;
    copy(): InnerField;
    equals(other: InnerField): boolean;
    addNumber(x: number, y: number, value: number): void;
    setNumberFieldAt(index: number, value: number): void;
    setNumberGarbageAt(index: number, value: number): void;
    setNumberAt(x: number, y: number, value: number): void;
    getNumberAt(x: number, y: number): Piece;
    getNumberAtIndex(index: number, isField: boolean): Piece;
    toFieldNumberArray(): Piece[];
    toGarbageNumberArray(): Piece[];
}
export declare class PlayField {
    static load(...lines: string[]): PlayField;
    static loadMinify(...lines: string[]): PlayField;
    private static loadInner;
    private readonly length;
    private pieces;
    constructor({ pieces, length }: {
        pieces?: Piece[];
        length?: number;
    });
    get(x: number, y: number): Piece;
    addOffset(x: number, y: number, value: number): void;
    set(x: number, y: number, piece: Piece): void;
    setAt(index: number, piece: Piece): void;
    fill({ type, rotation, x, y }: {
        type: Piece;
        rotation: Rotation;
        x: number;
        y: number;
    }): void;
    fillAll(positions: {
        x: number;
        y: number;
    }[], type: Piece): void;
    clearLine(): void;
    up(blockUp: PlayField): void;
    mirror(): void;
    shiftToLeft(): void;
    shiftToRight(): void;
    shiftToUp(): void;
    shiftToBottom(): void;
    toArray(): Piece[];
    get numOfBlocks(): number;
    copy(): PlayField;
    toShallowArray(): Piece[];
    clearAll(): void;
    equals(other: PlayField): boolean;
}
export declare function getBlockPositions(piece: Piece, rotation: Rotation, x: number, y: number): number[][];
export declare function getBlockXYs(piece: Piece, rotation: Rotation, x: number, y: number): {
    x: number;
    y: number;
}[];
export declare function getBlocks(piece: Piece, rotation: Rotation): number[][];
export declare function getPieces(piece: Piece): number[][];
